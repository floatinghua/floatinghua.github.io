{"meta":{"title":"唐杠杠的个人博客","subtitle":"Stay hungry,Stay foolish","description":"一个码农","author":"Tang","url":"https://floatinghua.github.io","root":"/"},"pages":[{"title":"link","date":"2020-09-08T02:22:54.000Z","updated":"2020-09-08T02:23:05.362Z","comments":true,"path":"link/index.html","permalink":"https://floatinghua.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-08T02:19:44.291Z","updated":"2020-09-08T02:19:44.291Z","comments":true,"path":"tags/index.html","permalink":"https://floatinghua.github.io/tags/index.html","excerpt":"","text":""},{"title":"分類","date":"2020-09-08T02:22:36.584Z","updated":"2020-09-08T02:22:36.584Z","comments":true,"path":"categories/index.html","permalink":"https://floatinghua.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"picgo处理hexo博客图片问题","slug":"picgo处理博客图片问题","date":"2020-08-28T08:52:09.000Z","updated":"2020-09-08T06:08:59.813Z","comments":true,"path":"2020/08/28/picgo处理博客图片问题/","link":"","permalink":"https://floatinghua.github.io/2020/08/28/picgo%E5%A4%84%E7%90%86%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/","excerpt":"","text":"picgo处理hexo博客图片问题 免费！速度快！简单！ 前提之前写博客都是先写好，发表到csdn，然后再发表到自己的博客地址，因为csdn大家都懂，所以今天解决下一直没处理的图片存储问题。 效果技术上因为用的是hexo，所以盯上了picgo，typor自己就支持所以配置起来很方便 可以看到下图粘贴图片的一瞬间就上传图片完成了，速度极快 方法首先需要你下载 picgo ， typora 应该做开发的都知道吧，一款很好用的md编辑器,然后需要你建一个码云仓库，当然你可以选择github（速度慢，容易加载失败），或者七牛云，因为我的七牛云拿去做其他事情了，所以就演示码云。 步骤安装好 先下载一个插件 搜索gitee就行 建好码云仓库，要是开源的，master分支可选，等下配置到master就行 然后生成自己的令牌一定要记住令牌，因为点击了就不会再次展示了 然后打开picgo选到gitee 填入自己的仓库地址（注意仓库地址是你选择克隆下载的那个地址后面的部分），token信息 然后打开typora 偏好设置，配置好就行了 总结总体来说，很简单，也很便宜，当然你可以选择其他方式，多动脑子。","categories":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"设计模式——单例模式","slug":"设计模式——单例模式","date":"2020-08-10T05:49:17.000Z","updated":"2020-09-08T06:09:22.574Z","comments":true,"path":"2020/08/10/设计模式——单例模式/","link":"","permalink":"https://floatinghua.github.io/2020/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式——单例模式概念：单例模式是设计模式中很常见的一种模式，各种框架，系统中都有应用。 其定义是单例对象的类只能允许一个实例存在。在许多时候整个系统只需要拥有一个全局对象，这样有利于我们系统系统整体的行为。 实现主要是以下两个步骤: 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例； 在该类内提供一个静态方法，当我们调用这个方法时，如果该类的引用不为空，就返回该类的引用，如果该类的引用为空，就创建该类的实例，并赋值给该类的引用。 单例模式可分为有状态的和无状态的。有状态的单例对象一般也是可变的单例对象，多 个单态对象在一起就可以作为一个状态仓库一样向外提供服务。没有状态的单例对象也就是 不变单例对象，仅用做提供工具函数。 适用场景： 需要频繁实例化然后销毁; 需要生成唯一序列的环境； 实例化耗时过多，但是又经常用到； 资源互相通信的环境 实现饿汉式12345678910111213public class HungryMod &#123; //私有化构造方法 private HungryMod() &#123; &#125; // 指向自己实例的私有静态引用 private static HungryMod mod = new HungryMod(); //静态工厂方法，提供给外部调用获得实例 public static HungryMod getInstance() &#123; return mod; &#125;&#125; 类的加载是按需加载，且加载一次。因此，在上述类被加载时，就是实例化一个对象指向自己的引用；而且类在整个生命周期只会被加载一次，因此只会创建一个实例。 优缺点​ 优点： ​ 写法简单，在类加载时就完成了实例化，避免线程同步问题 ​ 缺点： 没有延迟加载，因为这个实例是在类的加载时就创建了，如果没使用就造成了内存浪费 懒汉式12345678910111213141516public class LazyMod &#123;// 私有化构造方法 private LazyMod()&#123; &#125;// 指向自己的静态实例 private static LazyMod mod=null;// 提供给外部访问的静态方法 public static LazyMod getInstance()&#123; if (mod==null)&#123; mod=new LazyMod(); &#125; return mod; &#125;&#125; 懒汉式就是延迟加载的，在真正使用的时候才会去创建一个新的实例，指向自己的引用 优缺点​ 优点： 延迟加载，避免内存的浪费 ​ 缺点： if语句在多线程下，就可能出现多个实例的问题，所以多线程不适用 所以可以在懒汉模式下的静态方法上加一个锁 123456public synchronized static LazyMod getInstance()&#123; if (mod==null)&#123; mod=new LazyMod(); &#125; return mod; &#125; 线程安全的懒汉模式——这样虽然解决了线程安全问题，但是synchronized效率低。 双重加锁机制1234567891011121314151617181920212223public class DoubleLockMod &#123; // 空指向 private static DoubleLockMod mod = null; // 私有化构造函数 private DoubleLockMod() &#123; &#125; public static DoubleLockMod getInstance() &#123; // 第一次检查instance是否被实例化出来，如果没有进入if块 if (mod == null) &#123;// 类锁 synchronized (DoubleLockMod.class) &#123;// 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象 if (mod == null) &#123; mod = new DoubleLockMod(); &#125; &#125; &#125; return mod; &#125;&#125; 这样就解决了懒汉式下的线程问题，也解决了效率问题，这是最优秀的方案 总结单例模式在框架，系统中都很常见，也是简单的一种设计模式。当然单例模式还有个邪恶论，单例模式在java系统中存在很多陷阱和假象…… 参考1、高洪岩，Java多线程编程核心技术，机械工业出版社 2、https://www.cnblogs.com/xuwendong/p/9633985.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"'设计模式——工厂模式'","slug":"设计模式——工厂模式","date":"2020-08-05T07:54:33.000Z","updated":"2020-09-08T06:08:02.355Z","comments":true,"path":"2020/08/05/设计模式——工厂模式/","link":"","permalink":"https://floatinghua.github.io/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式——工厂模式首先不是写给萌新看的，观看前需要有javaSE的基础。文采、绘画水平不佳，还请担待。 工厂模式 主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提供灵活性的目的。 简单工厂模式 主要角色： 工厂类角色：本模式的核心，在java中往往由一个具体类实现 抽象产品角色：一般是具体产品继承或者实现的接口，在java中由接口或者抽象类来实现 具体产品：工厂类所创建的对象就是此角色的实例 逻辑如下： 简单工厂模式又称静态工厂方法模式。重命名上就可以看出这个模式一定很简单。 目的：它存 在的目的很简单：定义一个用于创建对象的接口。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Random;/** *工厂类 */public class SimpleFactor &#123; public static void main(String[] args) &#123; Phone phone = makePhone(); phone.describe(); &#125; public static Phone makePhone() &#123; Random random = new Random(); int i = random.nextInt(); if (i % 2 == 0) &#123; return new MiPhone(); &#125; else &#123; return new IPhone(); &#125; &#125;&#125;/** * 抽象产品角色 */interface Phone &#123; void describe();&#125;/** * 具体产品 */class MiPhone implements Phone &#123; @Override public void describe() &#123; System.out.println(\"小米手机进击高端市场了\"); &#125;&#125;/** * 具体产品 */class IPhone implements Phone &#123; @Override public void describe() &#123; System.out.println(\"苹果手机信号不好\"); &#125;&#125; 优缺点 优点： 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦； 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。 缺点： 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 工厂方法模式 主要角色 抽象工厂：提供创建产品的接口，调用者通过它访问具体工厂的工厂方法 具体工厂：实现抽象工厂的方法，完整自己具体产品的创建 抽象产品：定义产品的规范 具体产品：实现抽象产品的方法，由具体工程来创建对应的产品 逻辑如下： 和简单工厂模式（工厂负责生产所有的产品）相比，工厂方式模式将具体产品的任务分发给具体的产品工厂。 目的：也就是说定义了一个抽象工厂，其定义了产品的生产接口，但是不负责具体的产品，将具体任务分给具体的工厂 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Random;/** * 抽象工厂 */interface MakeCar &#123; Car make();&#125;/** * 抽象产品 */interface Car &#123; void descar();&#125;/** * 具体工厂1 */class BenzMake implements MakeCar &#123; @Override public Car make() &#123; System.out.println(\"开始制造奔驰\"); return new BenzCar(); &#125;&#125;/** * 具体工厂2 */class BmwMake implements MakeCar &#123; @Override public Car make() &#123; System.out.println(\"开始制造宝马\"); return new BMWCar(); &#125;&#125;/** * 具体产品1 */class BenzCar implements Car &#123; @Override public void descar() &#123; System.out.println(\"奔驰大标好\"); &#125;&#125;/** * 具体产品2 */class BMWCar implements Car &#123; @Override public void descar() &#123; System.out.println(\"宝马操控性好\"); &#125;&#125;/*** 调用*/public class Factory &#123; public static void main(String[] args) &#123; int i = new Random().nextInt(10); MakeCar make = null; if (i % 2 == 0) &#123; //指定具体的工厂来制造 make = new BenzMake(); &#125; else &#123; //指定具体的工厂来制造 make = new BmwMake(); &#125; //得到具体的产品 Car car = make.make(); //产品的特点 car.descar(); &#125;&#125; 优缺点 优点： 更符合开-闭原则新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可 简单工厂模式需要修改工厂类的判断逻辑 符合单一职责原则每个具体工厂类只负责创建对应的产品 简单工厂中的工厂类存在复杂的switch逻辑判断 不使用静态工厂方法，可以形成基于继承的等级结构。 简单工厂模式的工厂类使用静态工厂方法 总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 缺点： 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类； 一个具体工厂只能创建一种具体产品 抽象工厂模式 上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品，如果要生产另外一种产品，该怎么办？ 先来认识下产品族： 宝马的跑车，奔驰的跑车，都可以归类到跑车产品，而这个跑车产品就是一个产品族。 抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是最为抽象，最具一般性的 目的：给客户提供一个接口，可以创建多个产品族中的产品对象，而且使用抽象工厂还要满足以下条件： 系统中有多个产品族，而系统一次只可能消费其中一族产品。 同属于一个产品族的产品以其使用。 主要角色 抽象工厂角色：这是工厂方法模式的核心，与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 抽象产品角色：它是由具体产品继承的父类或者实现的接口。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。 逻辑如下 抽象产品A、抽象产品B 表示一个产品族（比如下面例子中的手表、随身听），具体工厂1、具体工厂2 就表示一个厂牌的工厂（比如下面例子的小米工厂、sony工厂），那么就简单了，小米工厂生产手表，随身听；sony工厂也可以生产手表，随身听 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.yx.design_mod.factory.simple;/** * 抽象工厂 */interface FactoryUnionAll &#123; Watch makeWatch(); Walkman makeWalkMan();&#125;/** * 抽象产品1 */interface Watch &#123; void showTime();&#125;/** * 抽象产品2 */interface Walkman &#123; void playMusic();&#125;/** * 具体工厂1 */class MibranFactory implements FactoryUnionAll &#123; @Override public Watch makeWatch() &#123; System.out.println(\"开始制造小米手表\"); return new MiWatch(); &#125; @Override public Walkman makeWalkMan() &#123; System.out.println(\"开始制造小米随身听\"); return new MiWalkman(); &#125;&#125;/*** 具体工厂2*/class SonyFactory implements FactoryUnionAll &#123; @Override public Watch makeWatch() &#123; System.out.println(\"开始制造sony手表\"); return new SonyWatch(); &#125; @Override public Walkman makeWalkMan() &#123; System.out.println(\"开始制造sony随身听\"); return new SonyWalkMan(); &#125;&#125;/** * 具体产品1 */class MiWatch implements Watch &#123; @Override public void showTime() &#123; System.out.println(\"小米滴滴滴\"); &#125;&#125;/** * 具体产品2 */class SonyWatch implements Watch &#123; @Override public void showTime() &#123; System.out.println(\"sony 哒哒哒\"); &#125;&#125;class MiWalkman implements Walkman &#123; @Override public void playMusic() &#123; System.out.println(\"小米音乐卡卡卡\"); &#125;&#125;class SonyWalkMan implements Walkman &#123; @Override public void playMusic() &#123; System.out.println(\"sony nb\"); &#125;&#125;/** * @author ：tangfan * @date ：Created in 2020/8/5 15:20 * @description： * @modified By： */public class AbstractFactory &#123; public static void main(String[] args) &#123; FactoryUnionAll mibranFactory = new MibranFactory(); FactoryUnionAll sonyFactory = new SonyFactory(); mibranFactory.makeWalkMan().playMusic(); mibranFactory.makeWatch().showTime(); sonyFactory.makeWatch().showTime(); sonyFactory.makeWalkMan().playMusic(); &#125;&#125; 优缺点 优点： 降低耦合抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展； 更符合开-闭原则新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 简单工厂模式需要修改工厂类的判断逻辑 符合单一职责原则每个具体工厂类只负责创建对应的产品 简单工厂中的工厂类存在复杂的switch逻辑判断 不使用静态工厂方法，可以形成基于继承的等级结构。 简单工厂模式的工厂类使用静态工厂方法 缺点： 抽象工厂模式很难支持新种类产品的变化。 这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"使用java-POI导出自定义表格","slug":"使用java-POI导出自定义表格","date":"2020-07-01T03:39:26.000Z","updated":"2020-09-08T06:07:18.810Z","comments":true,"path":"2020/07/01/使用java-POI导出自定义表格/","link":"","permalink":"https://floatinghua.github.io/2020/07/01/%E4%BD%BF%E7%94%A8java-POI%E5%AF%BC%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"首先看效果图问题：之前用的是hutool导出excel，可是hutool只能导出稍微简单一点得，复杂的只好自己手动来画了。所以去看了下poi的api学习了下，做了个简单的demo，其中api在这里查看poi中文文档 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.14&lt;/version&gt;&lt;/dependency&gt; 如果你用的是hutool的poi-ooxml 版本是4.12,那请自己替换对应方法，就是居中和字体加粗，因为在4.12中没有这些方法，自行更换就行 本次用到的poi常用的方法：12345678910111213141516171819202122232425262728293031323334353637创建excel工作簿对象 HSSFWorkbook workbook=new HSSFWorkbook();创建工作表对象 HSSFSheet sheet=workbook.createSheet(\"这里可写名字 可不写\");创建单元格样式 HSSFCellStyle style=workbook.createCellStyle(); 单元格设置颜色 style.setFillForegroundColor(IndexedColors.YELLOW.getIndex()); style.setFillPattern(CellStyle.SOLID_FOREGROUND); 设置字体才能生效 style.setFont(font); 设置水平居中 // 左右居中2 居右3 默认居左 style.setAlignment((short) align); 设置上下居中 // 上下居中1 style.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); 设置边框 style.setBorderRight((short) 2); style.setLocked(true);创建字体 HSSFFont font=workbook.createFont(); 指定字体 font.setFontName(\"宋体\"； 设置字体大小 font.setFontHeightInPoints((short) fontSize); 设置字体加粗 font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); 创建一行 HSSFRow row=sheet.createRow(rowNumber);创建单元格 HSSFCell cell=row.createCell(cellNumber); 设置单元格的样式 cell.setCellStyle(style);合并列 sheet.addMergedRegion(new CellRangeAddress(\"合并开始行\",\"合并结束行\",\"合并开始列\",\"合并结束列\")) 工具类其实总体上就是几个对象的操作而已,下面就是根据api写的工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255package com.yx.excel_export_self;import lombok.Data;import org.apache.poi.hssf.usermodel.*;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.IndexedColors;import org.apache.poi.ss.util.CellRangeAddress;import java.io.*;/** * @author ：tangfan * @date ：Created in 2020/6/11 10:36 * @description： * @modified By： */@Datapublic class MyExcel &#123; private static HSSFWorkbook workbook; private static HSSFSheet sheet; public static void main(String[] args) throws IOException &#123;// 根据你传入的字段合并表头 String[] headNames = new String[]&#123;\"微信昵称\", \"姓名\", \"性别\", \"年龄\", \"客户身份\", \"营养师\", \"健康管理师\" , \"销售人员\", \"服务名称\", \"购买时间\", \"生效日期\", \"结束日期\", \"注册时间\", \"渠道来源\", \"勋章\", \"预约时间\", \"哪里听说\"&#125;; //单元格的宽度 int colWidths[] = &#123;100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100&#125;; // 创建Excel工作簿对象 workbook = new HSSFWorkbook();// 创Excel工作表对象 可以传参自定义名称 sheet = workbook.createSheet(\"客户资料导出\");// 创建表头 int headCell = createHeadCell(headNames, colWidths); ByteArrayOutputStream baos = new ByteArrayOutputStream(); workbook.write(baos); byte[] ba = baos.toByteArray(); ByteArrayInputStream bais = new ByteArrayInputStream(ba); File f = new File(\"d:\\\\excel.xls\"); if (f.exists()) f.delete(); f.createNewFile(); FileOutputStream out = new FileOutputStream(f); HSSFWorkbook book = new HSSFWorkbook(bais); book.write(out); out.flush(); out.close(); &#125; /** * 创建样式 * * @param fontSize 字体大小 * @param align 水平位置 左右居中2 居右3 默认居左 垂直均为居中 * @param bold 是否加粗 * @return */ private static HSSFCellStyle getStyle(int fontSize, int align, boolean bold, boolean border) &#123; HSSFFont font = workbook.createFont();// 字体 font.setFontName(\"宋体\");// 字体大小 font.setFontHeightInPoints((short) fontSize); if (bold) &#123; font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); &#125; HSSFCellStyle style = workbook.createCellStyle();// 设置字体 style.setFont(font);// 左右居中2 居右3 默认居左 style.setAlignment((short) align);// 上下居中1 style.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); if (border) &#123; style.setBorderRight((short) 2); style.setBorderLeft((short) 2); style.setBorderBottom((short) 2); style.setBorderTop((short) 2); style.setLocked(true); &#125; return style; &#125; /** * 创建行元素 * * @param style 样式 * @param height 行高 * @param value 行显示的内容 * @param row1 起始行 * @param row2 结束行 * @param col1 起始列 * @param col2 结束列 */ private static void createRow(HSSFCellStyle style, int height, String value, int row1, int row2, int col1, int col2) &#123; sheet.addMergedRegion(new CellRangeAddress(row1, row2, col1, col2)); //设置从第row1行合并到第row2行，第col1列合并到col2列 HSSFRow rows = sheet.createRow(row1); //设置第几行 rows.setHeight((short) height); //设置行高 HSSFCell cell = rows.createCell(col1); //设置内容开始的列 cell.setCellStyle(style); //设置样式 cell.setCellValue(value); //设置该行的值 &#125; /** * 创建表头 * * @param headNames * @param colWidths */ private static int createHeadCell(String[] headNames, int colWidths[]) &#123;// 表头标题开始// 样式 HSSFCellStyle titleStyle = getStyle(15, 2, false, false);// 设置颜色 titleStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex()); titleStyle.setFillPattern(CellStyle.SOLID_FOREGROUND);// 创建第一行 createRow(titleStyle, 500, \"基础信息\", 0, 0, 0, headNames.length - 1);// 表头标题结束// 第二行表头开始 boolean b = (headNames != null &amp;&amp; headNames.length &gt; 0); if (b) &#123; HSSFRow row2 = sheet.createRow(1); row2.setHeight((short) 0x289); HSSFCell fcell = null;// 建立新的cell样式 HSSFCellStyle cellStyle = getStyle(10, 2, false, false); for (int i = 0; i &lt; headNames.length; i++) &#123; fcell = row2.createCell(i); fcell.setCellStyle(cellStyle); fcell.setCellValue(headNames[i]); if (colWidths != null &amp;&amp; i &lt; colWidths.length) &#123; sheet.setColumnWidth(i, 32 * colWidths[i]); &#125; &#125; &#125;// // 空一行 HSSFCellStyle blankStyle = getStyle(20, 2, false, false); createRow(blankStyle, 400, \"\", 3, 3, 0, headNames.length - 1);// 问卷信息 HSSFRow queryTitleRow = sheet.createRow(4); HSSFCell cell = queryTitleRow.createCell(0); cell.setCellStyle(getStyle(10, 2, false, false)); cell.setCellValue(\"问卷信息\");// 开始问卷信息详情 HSSFRow queryContentRow = sheet.createRow(5); HSSFCellStyle queryContentStyle = getStyle(10, 2, false, false); HSSFCellStyle blankCellStyle = getStyle(10, 2, false, false); queryContentRow.setRowStyle(queryContentStyle); for (int i = 0; i &lt; 22; i++) &#123; HSSFCell contentCell = queryContentRow.createCell(i); &#125; HSSFCellStyle style = getStyle(10, 2, false, false); // 设置颜色 style.setFillForegroundColor(IndexedColors.YELLOW.getIndex()); style.setFillPattern(CellStyle.SOLID_FOREGROUND);// 合并问卷详情的标题// 健康目标 sheet.addMergedRegion(new CellRangeAddress(5, 5, 0, 2)); HSSFCell cell1 = queryContentRow.getCell(0); cell1.setCellValue(\"健康目标\"); cell1.setCellStyle(style);// 生活习惯 sheet.addMergedRegion(new CellRangeAddress(5, 5, 4, 6)); HSSFCell cell2 = queryContentRow.getCell(4); cell2.setCellValue(\"生活习惯\"); cell2.setCellStyle(style);// 身体状况，亲属疾病 sheet.addMergedRegion(new CellRangeAddress(5, 5, 8, 10)); HSSFCell cell3 = queryContentRow.getCell(8); cell3.setCellValue(\"身体状况-亲属疾病\"); cell3.setCellStyle(style);// 体检指标 sheet.addMergedRegion(new CellRangeAddress(5, 5, 12, 15)); HSSFCell cell4 = queryContentRow.getCell(12); cell4.setCellValue(\"体检指标\"); cell4.setCellStyle(style);// 用药信息 sheet.addMergedRegion(new CellRangeAddress(5, 5, 17, 22)); HSSFCell cell5 = queryContentRow.getCell(17); cell5.setCellValue(\"用药信息\"); cell5.setCellStyle(style);// 每个目标分类下的小标题 HSSFRow queryContentSmallTitle = sheet.createRow(6); for (int i = 0; i &lt; 23; i++) &#123; HSSFCell contentCell = queryContentSmallTitle.createCell(i); &#125;// 健康目标 queryContentSmallTitle.getCell(0).setCellValue(\"序号\"); queryContentSmallTitle.getCell(1).setCellValue(\"问题\"); queryContentSmallTitle.getCell(2).setCellValue(\"内容\");// 生活习惯 queryContentSmallTitle.getCell(4).setCellValue(\"序号\"); queryContentSmallTitle.getCell(5).setCellValue(\"问题\"); queryContentSmallTitle.getCell(6).setCellValue(\"内容\");// 身体状况-亲属疾病 queryContentSmallTitle.getCell(8).setCellValue(\"序号\"); queryContentSmallTitle.getCell(9).setCellValue(\"问题\"); queryContentSmallTitle.getCell(10).setCellValue(\"内容\");// 体检指标 queryContentSmallTitle.getCell(12).setCellValue(\"序号\"); queryContentSmallTitle.getCell(13).setCellValue(\"类型\"); queryContentSmallTitle.getCell(14).setCellValue(\"值\"); queryContentSmallTitle.getCell(15).setCellValue(\"参考范围\");// 用药信息 queryContentSmallTitle.getCell(17).setCellValue(\"序号\"); queryContentSmallTitle.getCell(18).setCellValue(\"药物名称\"); queryContentSmallTitle.getCell(19).setCellValue(\"使用剂量\"); queryContentSmallTitle.getCell(20).setCellValue(\"用药频次\"); queryContentSmallTitle.getCell(21).setCellValue(\"用药时长\"); queryContentSmallTitle.getCell(22).setCellValue(\"用途\"); for (int i = 8; i &lt; 50; i++) &#123; for (int j = 0; j &lt; 23; j++) &#123; sheet.createRow(i).createCell(j); &#125; &#125; //从哪一行开始渲染表体 return 0; &#125;&#125; 以上就是全部内容，poi的api还有很多没学习到，Stay hungry,Stay foolish!","categories":[{"name":"java","slug":"java","permalink":"https://floatinghua.github.io/categories/java/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"poi","slug":"poi","permalink":"https://floatinghua.github.io/tags/poi/"},{"name":"api","slug":"api","permalink":"https://floatinghua.github.io/tags/api/"}]},{"title":"Linux和Windows下集成海康摄像头(特别解决linux加载不到库)","slug":"Linux和Windows下集成海康摄像头-特别解决linux加载不到库","date":"2020-07-01T03:38:55.000Z","updated":"2020-09-08T06:09:10.670Z","comments":true,"path":"2020/07/01/Linux和Windows下集成海康摄像头-特别解决linux加载不到库/","link":"","permalink":"https://floatinghua.github.io/2020/07/01/Linux%E5%92%8CWindows%E4%B8%8B%E9%9B%86%E6%88%90%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4-%E7%89%B9%E5%88%AB%E8%A7%A3%E5%86%B3linux%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%88%B0%E5%BA%93/","excerpt":"","text":"问题最近要集成海康摄像头部署到linux服务器，但是一直调用不到so文件，所以记录下解决过程，由于自己不熟悉jna，所以请轻喷，Stay Hungry,Stay Foolish. 海康sdk官方下载地址 前期准备至于为什么先讲linux等下就知道了，linux的sdk下载下来目录如下： 开发文档有自己的业务需求就看对应的开放文档 我们直接看LinuxJavaDemo文件夹 这边我选择的是方法一，但是不是在系统的/usr/lib文件下，自己新建的文件夹 linux准备工作 linux下搭配jdk1.8，我这边linux服务器新建了一个目录（/home/opt/hcnet）来存放下面的so文件 上传文件到linux目录下 就是图中的lib文件,所有的都上传到你的linux目录 创建lib文件夹引入sdk包中的examples.jar和jna.jar在pom中添加 不然会报错 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.sun.jna&lt;/groupId&gt; &lt;artifactId&gt;yx&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/jna.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jna.examples&lt;/groupId&gt; &lt;artifactId&gt;yx&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/examples.jar&lt;/systemPath&gt; &lt;/dependency&gt; 打包添加如下配置 开始集成 将linux中的HCNetSDK.java放到项目中，修改代码，将他初始化的地方注释掉，我们自己初始化 下面就是自己的初始化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.yx.hkdemo.config;import com.sun.jna.Native;import com.sun.jna.NativeLong;import com.sun.jna.Platform;import com.yx.hkdemo.HCNetSDK;import java.io.File;/** * @author ：tangfan * @date ：Created in 2020/5/25 17:36 * @description： * @modified By： */public class GetHCNetSdk &#123; public static HCNetSDK hcNetSDK = null; //windows下的路径 String PATH_WIN = System.getProperty(\"user.dir\") + File.separator + \"hkwinlib\" + File.separator + \"HCNetSDK\"; String PATH_LINUX = \"/home/opt/hcnet/libhcnetsdk.so\"; private HCNetSDK.NET_DVR_DEVICEINFO_V30 deviceInfo;//设备信息 private NativeLong lUserID;//用户句柄 private NativeLong lAlarmHandle;//报警布防句柄 // private HCNetSDK.FMSGCallBack_V31 fMSFCallBack_V31;//报警回调函数实现 private HCNetSDK.FMSGCallBack fMSFCallBack;//报警回调函数实现 private String deviceIP;//已登录设备的IP地址 private int devicePort;//设备端口号 private String username;//设备用户名 private String password;//设备登陆密码 private boolean init_flag;//初始化识别标志 private boolean reg_flag;//设备注册识别标志 public GetHCNetSdk() &#123; install(); &#125; private void install() &#123; if (Platform.isWindows()) &#123; hcNetSDK = (HCNetSDK) Native.loadLibrary(PATH_WIN, HCNetSDK.class); &#125; if (Platform.isLinux()) &#123; hcNetSDK = (HCNetSDK) Native.loadLibrary(PATH_LINUX, HCNetSDK.class); &#125; &#125;&#125; 如果在linux上运行报错，请在linux下的hcNetSDK = (HCNetSDK) Native.loadLibrary(PATH_LINUX, HCNetSDK.class);后面加入官方的这段代码，并且修改成自己的路径，我的是/home/opt/hcnet代码在下面： 12345678910111213141516171819202122 //设置HCNetSDKCom组件库所在路径// /home/opt/hcnet/libhcnetsdk.so// /home/opt/hcnet String strPathCom = \"/home/opt/hcnet\"; HCNetSDK.NET_DVR_LOCAL_SDK_PATH struComPath = new HCNetSDK.NET_DVR_LOCAL_SDK_PATH(); System.arraycopy(strPathCom.getBytes(), 0, struComPath.sPath, 0, strPathCom.length()); struComPath.write(); hcNetSDK.NET_DVR_SetSDKInitCfg(2, struComPath.getPointer());//设置libcrypto.so所在路径 HCNetSDK.BYTE_ARRAY ptrByteArrayCrypto = new HCNetSDK.BYTE_ARRAY(256); String strPathCrypto = \"/home/opt/hcnet/libcrypto.so\"; System.arraycopy(strPathCrypto.getBytes(), 0, ptrByteArrayCrypto.byValue, 0, strPathCrypto.length()); ptrByteArrayCrypto.write(); hcNetSDK.NET_DVR_SetSDKInitCfg(3, ptrByteArrayCrypto.getPointer());//设置libssl.so所在路径 HCNetSDK.BYTE_ARRAY ptrByteArraySsl = new HCNetSDK.BYTE_ARRAY(256); String strPathSsl = \"/home/opt/hcnet/libssl.so\"; System.arraycopy(strPathSsl.getBytes(), 0, ptrByteArraySsl.byValue, 0, strPathSsl.length()); ptrByteArraySsl.write(); hcNetSDK.NET_DVR_SetSDKInitCfg(4, ptrByteArraySsl.getPointer()); 编写工具类，自己写方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package com.yx.hkdemo;import com.sun.jna.NativeLong;import com.sun.jna.Pointer;import com.sun.jna.ptr.IntByReference;import com.sun.jna.ptr.NativeLongByReference;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import javax.swing.*;//import org.apache.commons.lang.StringUtils;//import cc.eguid.FFmpegCommandManager.FFmpegManager;//import cc.eguid.FFmpegCommandManager.FFmpegManagerImpl;//import com.dfzx.common.util.CommonKit;@Data@AllArgsConstructorpublic class HCNetTools &#123; HCNetSDK hCNetSDK = null; HCNetSDK.NET_DVR_DEVICEINFO_V30 m_strDeviceInfo;//设备信息 HCNetSDK.NET_DVR_IPPARACFG m_strIpparaCfg;//IP参数 HCNetSDK.NET_DVR_CLIENTINFO m_strClientInfo;//用户参数 boolean bRealPlay;//是否在预览. String m_sDeviceIP;//已登录设备的IP地址 NativeLong lUserID;//用户句柄 NativeLong lPreviewHandle;//预览句柄 NativeLongByReference m_lPort;//回调预览时播放库端口指针 public HCNetTools(HCNetSDK sdk) &#123; JPopupMenu.setDefaultLightWeightPopupEnabled(false);//防止被播放窗口(AWT组件)覆盖 lUserID = new NativeLong(-1); lPreviewHandle = new NativeLong(-1); m_lPort = new NativeLongByReference(new NativeLong(-1)); this.hCNetSDK = sdk; &#125;// FFmpegManager manager;//rstp转rmtp工具 //FRealDataCallBack fRealDataCallBack;//预览回调函数实现 public HCNetTools() &#123; JPopupMenu.setDefaultLightWeightPopupEnabled(false);//防止被播放窗口(AWT组件)覆盖 lUserID = new NativeLong(-1); lPreviewHandle = new NativeLong(-1); m_lPort = new NativeLongByReference(new NativeLong(-1)); //fRealDataCallBack= new FRealDataCallBack(); &#125; /** * 初始化资源配置 */ public int initDevices() &#123; if (!hCNetSDK.NET_DVR_Init()) return 1;//初始化失败 return 0; &#125; /** * 设备注册 * * @param name 设备用户名 * @param password 设备登录密码 * @param ip IP地址 * @param port 端口 * @return 结果 */ public int deviceRegist(String name, String password, String ip, String port) &#123; if (bRealPlay) &#123;//判断当前是否在预览 return 2;//\"注册新用户请先停止当前预览\"; &#125; if (lUserID.longValue() &gt; -1) &#123;//先注销,在登录 hCNetSDK.NET_DVR_Logout_V30(lUserID); lUserID = new NativeLong(-1); &#125; System.out.println(\"注册里面:lUserId:\"+lUserID); //注册(既登录设备)开始 m_sDeviceIP = ip; m_strDeviceInfo = new HCNetSDK.NET_DVR_DEVICEINFO_V30();//获取设备参数结构 System.out.println(\"注册里面：ip:\"+m_sDeviceIP+\" info:\"+m_strDeviceInfo); lUserID = hCNetSDK.NET_DVR_Login_V30(m_sDeviceIP, (short) Integer.parseInt(\"8000\"), name, password, m_strDeviceInfo);//登录设备// NativeLong lUserID, int dwCommand, NativeLong lChannel, Pointer lpInBuffer, int dwInBufferSize System.out.println(\"登录后的id\"+lUserID); int i = hCNetSDK.NET_DVR_GetLastError(); System.out.println(\"登录错误代码：\"+i); m_strIpparaCfg = new HCNetSDK.NET_DVR_IPPARACFG(); Pointer lpIpParaConfig = m_strIpparaCfg.getPointer(); boolean b = hCNetSDK.NET_DVR_SetDVRConfig(lUserID, HCNetSDK.NET_DVR_GET_IPPARACFG, new NativeLong(0), lpIpParaConfig, m_strIpparaCfg.size()); int seti = hCNetSDK.NET_DVR_GetLastError(); System.out.println(\"setConfig\"+seti); System.out.println(\"b:\"+b); long userID = lUserID.longValue(); System.out.println(\"注册里面：userId:\"+userID); if (userID == -1) &#123; m_sDeviceIP = \"\";//登录未成功,IP置为空 return 3;//\"注册失败\"; &#125; return 0; &#125; /** * 获取设备通道 */ public int getChannelNumber() &#123; IntByReference ibrBytesReturned = new IntByReference(0);//获取IP接入配置参数 boolean bRet = false; int iChannelNum = -1; m_strIpparaCfg = new HCNetSDK.NET_DVR_IPPARACFG(); m_strIpparaCfg.write(); Pointer lpIpParaConfig = m_strIpparaCfg.getPointer(); bRet = hCNetSDK.NET_DVR_GetDVRConfig(lUserID, HCNetSDK.NET_DVR_GET_IPPARACFG, new NativeLong(0), lpIpParaConfig, m_strIpparaCfg.size(), ibrBytesReturned); int geti = hCNetSDK.NET_DVR_GetLastError(); System.out.println(\"geti:\"+geti); m_strIpparaCfg.read(); String devices = \"\"; System.out.println(\"bRet:\"+bRet); if (!bRet) &#123; //设备不支持,则表示没有IP通道 System.out.println(\"C:\"+m_strDeviceInfo.byChanNum); for (int iChannum = 0; iChannum &lt; m_strDeviceInfo.byChanNum; iChannum++) &#123; devices = \"Camera\" + (iChannum + m_strDeviceInfo.byStartChan); &#125; &#125; else &#123; System.out.println(\"IP\"+HCNetSDK.MAX_IP_CHANNEL); for (int iChannum = 0; iChannum &lt; HCNetSDK.MAX_IP_CHANNEL; iChannum++) &#123; if (m_strIpparaCfg.struIPChanInfo[iChannum].byEnable == 1) &#123; devices = \"IPCamera\" + (iChannum + m_strDeviceInfo.byStartChan); &#125; &#125; &#125; System.out.println(\"通道：\"+devices); if (devices != null &amp;&amp; devices != \"\") &#123; if (devices.charAt(0) == 'C') &#123;//Camara开头表示模拟通道 //子字符串中获取通道号 System.out.println(\"C\"); iChannelNum = Integer.parseInt(devices.substring(6)); &#125; else &#123; if (devices.charAt(0) == 'I') &#123;//IPCamara开头表示IP通道 System.out.println(\"I\"); //子字符创中获取通道号,IP通道号要加32 iChannelNum = Integer.parseInt(devices.substring(8)) + 32; &#125; else &#123; return 4; &#125; &#125; &#125; return iChannelNum; &#125; /** * 获取通道信号状态 * * @param channum * @return */ public int getSignalStatus(int channum) &#123; //获取设备状态 HCNetSDK.NET_DVR_WORKSTATE_V30 devwork = new HCNetSDK.NET_DVR_WORKSTATE_V30(); if (!hCNetSDK.NET_DVR_GetDVRWorkState_V30(lUserID, devwork)) &#123; //返回Boolean值，判断是否获取设备能力 System.out.println(\"返回设备状态失败\"); &#125; return devwork.struChanStatic[channum].bySignalStatic; &#125; /** * 拍照 * * @return */ public boolean takePic() &#123; //拍照 HCNetSDK.NET_DVR_JPEGPARA strJpeg = new HCNetSDK.NET_DVR_JPEGPARA(); strJpeg.wPicQuality = 1; //图像参数 strJpeg.wPicSize = 2; String filePath = \"E:\\\\123q.jpg\"; lPreviewHandle.setValue(m_strDeviceInfo.byStartChan + 32); boolean b = hCNetSDK.NET_DVR_CaptureJPEGPicture(lUserID, lPreviewHandle, strJpeg, filePath);//尝试用NET_DVR_CaptureJPEGPicture_NEW方法，但不是报43就是JDK崩溃.... if (!b) &#123;//单帧数据捕获图片 System.out.println(\"抓拍失败!\" + \" err: \" + hCNetSDK.NET_DVR_GetLastError()); &#125; else &#123; System.out.println(\"抓拍成功\"); &#125; return b; &#125; /** * 释放SDK */ public void shutDownDev() &#123; //如果已经注册,注销 if (lUserID.longValue() &gt; -1) &#123; hCNetSDK.NET_DVR_Logout_V30(lUserID); &#125; hCNetSDK.NET_DVR_Cleanup(); &#125;&#125; 分别调用就行了 Linux下运行成功的截图 win准备和集成上面linux都集成好了，windows就只是需要修改一点东西就好了 因为我下载的是最新的linux SDK所以HCNetSDK.java就不需要做更改 继续新建文件夹 引入win下面的dll文件 全部引入 因为上面的初始化类判断了linux和windows系统的，所以直接调用就可以了，因为linux下的sdk中的方法和win的方法基本一致，所以直接用就行了 总结集成linux出现的问题就是加载不到库，在摸索官方的sdk后，终于成功，还是自己太年轻，sdk看得不够多","categories":[{"name":"linux","slug":"linux","permalink":"https://floatinghua.github.io/categories/linux/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"springboot","slug":"springboot","permalink":"https://floatinghua.github.io/tags/springboot/"},{"name":"集成","slug":"集成","permalink":"https://floatinghua.github.io/tags/%E9%9B%86%E6%88%90/"},{"name":"海康","slug":"海康","permalink":"https://floatinghua.github.io/tags/%E6%B5%B7%E5%BA%B7/"}]},{"title":"springboot2.1.5 整合es6.3.0","slug":"springboot2-1-5-整合es6-3-0","date":"2020-07-01T03:37:21.000Z","updated":"2020-09-08T06:08:50.152Z","comments":true,"path":"2020/07/01/springboot2-1-5-整合es6-3-0/","link":"","permalink":"https://floatinghua.github.io/2020/07/01/springboot2-1-5-%E6%95%B4%E5%90%88es6-3-0/","excerpt":"","text":"搭建环境如下： springboot 2.1.5 elasticsearch 版本6.3.0 kibana 版本6.3.0 IK Analyzer for Elasticsearch 版本 6.3.0 如需设置账户密码登录要购买es的商业版 jdk1.8 安装elasticsearch6.3.0下载地址：es6.3.0 下载安装解压后就可以 启动es 进入安装目录下的bin 运行elasticsearch.bat 出现如下表示启动成功在浏览器中访问默认的端口号 9200 以下步骤根据个人需求 可以将es安装成windows的服务 1234567891011安装服务elasticsearch-service.bat install删除已安装的es服务elasticsearch-service.bat remove启动es服务elasticsearch-service.bat start停止服务elasticsearch-service.bat stop 安装kibana6.3.0下载地址:kibana下载 下载安装解压 由于是6.X版本不支持修改配置文件来汉化，而且汉化过程不可逆，所以根据个人需求进行汉化 汉化地址：https://github.com/anbai-inc/Kibana_Hanization 启动kibana 前提是es已经是启动状态，否则会报错，进入安装目录下的bin 运行kibana .bat 如下启动成功 访问默认端口5601 成功 安装ik分词器下载地址：ik分词器下载 版本选择6.3.0 下载解压到es安装目录下的plugins 新建一个ik文件夹 重新启动es kibana es启动过程中出现 表示插件加载成功 springboot 整合esspringboot版本2.1.5注意版本冲突 springboot2.1.5 支持的es版本es和kibana版本不对连接不上 es依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 版本如下 配置类 123# 指定默认集群名和ip端口spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 新建实体类 @Doucument 进行数据存储的基本单元 以json格式存储的记录，indexName 指定创建存储的索引名 @Mapping 指定resources下面的json文件 来定义分词规则 @Id 一定要加在主键上 @Field 指定分词器的名称，只配置了ik分词器 123456789101112131415161718192021@Data@Document(indexName = \"testmapping\")@Mapping(mappingPath = \"course_mapping.json\")public class demo implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @ApiModelProperty(\"课程id\") private Integer cid; @ApiModelProperty(\"课程名\") //analyzer：分词器名称 //ik_max_word：会将文本做最细粒度的拆分 //ik_smart：会将文本做最粗粒度的拆分 @Field(analyzer = \"ik_max_word\", searchAnalyzer = \"ik_max_word\", type = FieldType.Text) private String name; @ApiModelProperty(\"教师id\") private Integer teacherId;&#125; 在resources下面建立指定的json文件 在需要分词的属性下加上 analyzer和search_analyzer 并指定分词格式 1234567891011121314151617&#123; \"demo\": &#123; \"properties\": &#123; \"cid\": &#123; \"type\": \"long\" &#125;, \"name\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"teacherId\": &#123; \"type\": \"long\" &#125; &#125; &#125;&#125; 存储优化分词，就是将ElasticSearch文档中字段值按照一定的切分规则分为多个待匹配靶点，只有搜索关键词命中其中的靶点才会将该字段值对应的文档放在返回结果中。 检索优化分词，就是将用户输入的搜索关键词按照一定的切分规则分为多个靶点，然后根据这些靶点去匹配ElasticSearch中的所有待匹配靶点。根据这些靶点的匹配程度，ElasticSearch会计算得分，根据匹配度即得分情况从高到底返回搜索结果。如果一个靶点都没有匹配上，得分为0即不返回任何结果。 以”中华人民共和国国歌”为例，ik分词的两种分词规则的效果如下： ik_max_word分词效果：“中华”，“中华人民”，“中华人民共和国”，“人民”，“人民共和国”，“共和”，“共和国”，“华人”，“国”，“国歌”。 ik_smart分词效果：“中华人民共和国”，“国歌”。 上面的具体分词效果可以在kibana中查看 12345POST testmapping/_analyze&#123; \"field\": \"name\", \"text\": \"中华人民共和国国歌\"&#125; 编写接口继承ElasticsearchRepository&lt;T, T&gt;传入实体类、主键类型，就可以调用封装的方法 编写自己的测试类 第一步创建索引 123456789@Autowiredprivate ElasticsearchTemplate template;//通过template// createIndex 创建索引template.createIndex(T.class);// 设置索引对应字段的分词规则(根据***.json中的设置开始生效)template.putMapping(T.class); 增 通过刚刚的继承了ElasticsearchRepository的接口调用方法 12interface.saveAll(Iterable&lt;? extends T&gt; entities)interface.save(S entity) 删 1234567deleteById(ID id)delete(T entity)deleteAll(Iterable&lt;? extends T&gt; entities)deleteAll() //删除索引 template.deleteIndex(T.class) 查 1234567findById(Id id)existsById(ID id);findAll();findAllById(Iterable&lt;ID&gt; ids); 混合分页排序查询混合搜索指模糊，单个字段查询，匹配所有的，多个字段匹配某一个值，可以设置权重权重官方解释：权重解释 权重就影响上面提到的匹配度，分数： 查询时的权重提升 是可以用来影响相关度的主要工具，任意类型的查询都能接受 boost 参数。将 boost 设置为 2 ，并不代表最终的评分 _score 是原值的两倍；实际的权重值会经过归一化和一些其他内部优化过程。尽管如此，它确实想要表明一个提升值为 2 的句子的重要性是提升值为 1 语句的两倍。在实际应用中，无法通过简单的公式得出某个特定查询语句的 “正确” 权重提升值，只能通过不断尝试获得。需要记住的是 boost 只是影响相关度评分的其中一个因子；它还需要与其他因子相互竞争。选择权重，检查结果，如此反复。 12345678910111213141516171819202122232425//混合查询使用/*** matchQuery : 单个字段查询* matchAllQuery : 匹配所有* multiMatchQuery : 多个字段匹配某一个值* wildcardQuery : 模糊查询* boost : 设置权重,数值越大权重越大**/ // 下面可以多个选择 DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();// 单个字段查询 QueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(\"cname\",reqQueryDto.getCname().toLowerCase());// wildcardQuery : 模糊查询 QueryBuilder wildcardCodeQuery = QueryBuilders.wildcardQuery(\"cname\", reqQueryDto.getCname().toLowerCase()); disMaxQueryBuilder.add(wildcardCodeQuery).add(matchQueryBuilder); SearchQuery searchQuery = new NativeSearchQueryBuilder()// 指定查询方式 .withQuery(disMaxQueryBuilder)// 分页 .withPageable(PageRequest.of(reqQueryDto.getPage(), reqQueryDto.getSize()))// 排序规则 .withSort(SortBuilders.fieldSort(\"cid\").order(SortOrder.DESC)) .build(); Page&lt;Course&gt; search = courseInterface.search(searchQuery); 搭建环境如下： springboot 2.1.5 elasticsearch 版本6.3.0 kibana 版本6.3.0 IK Analyzer for Elasticsearch 版本 6.3.0 如需设置账户密码登录要购买es的商业版 jdk1.8 安装elasticsearch6.3.0下载地址：es6.3.0 下载安装解压后就可以 启动es 进入安装目录下的bin 运行elasticsearch.bat 出现如下表示启动成功在浏览器中访问默认的端口号 9200 以下步骤根据个人需求 可以将es安装成windows的服务 1234567891011安装服务elasticsearch-service.bat install删除已安装的es服务elasticsearch-service.bat remove启动es服务elasticsearch-service.bat start停止服务elasticsearch-service.bat stop 安装kibana6.3.0下载地址:kibana下载 下载安装解压 由于是6.X版本不支持修改配置文件来汉化，而且汉化过程不可逆，所以根据个人需求进行汉化 汉化地址：https://github.com/anbai-inc/Kibana_Hanization 启动kibana 前提是es已经是启动状态，否则会报错，进入安装目录下的bin 运行kibana .bat 如下启动成功 访问默认端口5601 成功 安装ik分词器下载地址：ik分词器下载 版本选择6.3.0 下载解压到es安装目录下的plugins 新建一个ik文件夹 重新启动es kibana es启动过程中出现 表示插件加载成功 springboot 整合esspringboot版本2.1.5注意版本冲突 springboot2.1.5 支持的es版本es和kibana版本不对连接不上 es依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 版本如下 配置类 123# 指定默认集群名和ip端口spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 新建实体类 @Doucument 进行数据存储的基本单元 以json格式存储的记录，indexName 指定创建存储的索引名 @Mapping 指定resources下面的json文件 来定义分词规则 @Id 一定要加在主键上 @Field 指定分词器的名称，只配置了ik分词器 123456789101112131415161718192021@Data@Document(indexName = \"testmapping\")@Mapping(mappingPath = \"course_mapping.json\")public class demo implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @ApiModelProperty(\"课程id\") private Integer cid; @ApiModelProperty(\"课程名\") //analyzer：分词器名称 //ik_max_word：会将文本做最细粒度的拆分 //ik_smart：会将文本做最粗粒度的拆分 @Field(analyzer = \"ik_max_word\", searchAnalyzer = \"ik_max_word\", type = FieldType.Text) private String name; @ApiModelProperty(\"教师id\") private Integer teacherId;&#125; 在resources下面建立指定的json文件 在需要分词的属性下加上 analyzer和search_analyzer 并指定分词格式 1234567891011121314151617&#123; \"demo\": &#123; \"properties\": &#123; \"cid\": &#123; \"type\": \"long\" &#125;, \"name\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"teacherId\": &#123; \"type\": \"long\" &#125; &#125; &#125;&#125; 存储优化分词，就是将ElasticSearch文档中字段值按照一定的切分规则分为多个待匹配靶点，只有搜索关键词命中其中的靶点才会将该字段值对应的文档放在返回结果中。 检索优化分词，就是将用户输入的搜索关键词按照一定的切分规则分为多个靶点，然后根据这些靶点去匹配ElasticSearch中的所有待匹配靶点。根据这些靶点的匹配程度，ElasticSearch会计算得分，根据匹配度即得分情况从高到底返回搜索结果。如果一个靶点都没有匹配上，得分为0即不返回任何结果。 以”中华人民共和国国歌”为例，ik分词的两种分词规则的效果如下： ik_max_word分词效果：“中华”，“中华人民”，“中华人民共和国”，“人民”，“人民共和国”，“共和”，“共和国”，“华人”，“国”，“国歌”。 ik_smart分词效果：“中华人民共和国”，“国歌”。 上面的具体分词效果可以在kibana中查看 12345POST testmapping/_analyze&#123; \"field\": \"name\", \"text\": \"中华人民共和国国歌\"&#125; 编写接口继承ElasticsearchRepository&lt;T, T&gt;传入实体类、主键类型，就可以调用封装的方法 编写自己的测试类 第一步创建索引 123456789@Autowiredprivate ElasticsearchTemplate template;//通过template// createIndex 创建索引template.createIndex(T.class);// 设置索引对应字段的分词规则(根据***.json中的设置开始生效)template.putMapping(T.class); 增 通过刚刚的继承了ElasticsearchRepository的接口调用方法 12interface.saveAll(Iterable&lt;? extends T&gt; entities)interface.save(S entity) 删 1234567deleteById(ID id)delete(T entity)deleteAll(Iterable&lt;? extends T&gt; entities)deleteAll() //删除索引 template.deleteIndex(T.class) 查 1234567findById(Id id)existsById(ID id);findAll();findAllById(Iterable&lt;ID&gt; ids); 混合分页排序查询混合搜索指模糊，单个字段查询，匹配所有的，多个字段匹配某一个值，可以设置权重权重官方解释：权重解释 权重就影响上面提到的匹配度，分数： 查询时的权重提升 是可以用来影响相关度的主要工具，任意类型的查询都能接受 boost 参数。将 boost 设置为 2 ，并不代表最终的评分 _score 是原值的两倍；实际的权重值会经过归一化和一些其他内部优化过程。尽管如此，它确实想要表明一个提升值为 2 的句子的重要性是提升值为 1 语句的两倍。在实际应用中，无法通过简单的公式得出某个特定查询语句的 “正确” 权重提升值，只能通过不断尝试获得。需要记住的是 boost 只是影响相关度评分的其中一个因子；它还需要与其他因子相互竞争。选择权重，检查结果，如此反复。 12345678910111213141516171819202122232425//混合查询使用/*** matchQuery : 单个字段查询* matchAllQuery : 匹配所有* multiMatchQuery : 多个字段匹配某一个值* wildcardQuery : 模糊查询* boost : 设置权重,数值越大权重越大**/ // 下面可以多个选择 DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();// 单个字段查询 QueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(\"cname\",reqQueryDto.getCname().toLowerCase());// wildcardQuery : 模糊查询 QueryBuilder wildcardCodeQuery = QueryBuilders.wildcardQuery(\"cname\", reqQueryDto.getCname().toLowerCase()); disMaxQueryBuilder.add(wildcardCodeQuery).add(matchQueryBuilder); SearchQuery searchQuery = new NativeSearchQueryBuilder()// 指定查询方式 .withQuery(disMaxQueryBuilder)// 分页 .withPageable(PageRequest.of(reqQueryDto.getPage(), reqQueryDto.getSize()))// 排序规则 .withSort(SortBuilders.fieldSort(\"cid\").order(SortOrder.DESC)) .build(); Page&lt;Course&gt; search = courseInterface.search(searchQuery);","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://floatinghua.github.io/categories/elasticsearch/"}],"tags":[{"name":"整合","slug":"整合","permalink":"https://floatinghua.github.io/tags/%E6%95%B4%E5%90%88/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://floatinghua.github.io/tags/elasticsearch/"}]},{"title":"初识spring","slug":"初识spring","date":"2020-07-01T03:35:38.000Z","updated":"2020-09-08T06:39:44.744Z","comments":true,"path":"2020/07/01/初识spring/","link":"","permalink":"https://floatinghua.github.io/2020/07/01/%E5%88%9D%E8%AF%86spring/","excerpt":"","text":"什么是框架?在特定的领域将总结的最佳实践编写成固定流程，帮助我们更加高效，更为健壮的编写。 总结的最佳实践 ，这就表明框架已经是完成了一些特定的功能，自己已经实现了一些功能，不同的框架完成了不同的功能； 固定流程，说明框架本身是有一套流程，需要实现的功能按照其流程来，就能达到效果。 帮助我们，框架本身是不会运行点，在框架的帮助下，配合其他的程序，框架就能有效的帮助我们省去很多步骤，直接调用其本身，来达到功能的实现。 Spring概诉Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。 Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。 Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。 Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。 Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack（一站式）轻量级开源框架。 上面的干货是不是很枯燥，那我们看下Spring ==集成的模块== Spring集成的模块1 核心容器 Spring-beans:IoC的实现，配置文件的访问、创建和管理； Spring-core：核心工具包； Spring-context：封装IoC容器，提供扩展功能； SpEL:Spring的表达式支持 2.基础服务 AOP：面向切面编程的支持； Aspect：模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架； Instrumentation：字节码操作； Messaging：对消息服务的支持 3.功能 transactions:对事务的支持； JDBC:Spring对JDBC的封装； ORM：Spring对ORM的封装 4.WEB Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。 Spring的核心理念——IoC容器在讲解IoC的时候我们先来回想，之前写MVC三层的时候IoC:Inversion of Control 控制反转，通俗一点就是控制权由调用的类，转为Spring容器，由Spring容器来==创建实例以及依赖注入==。 Bean的四种实例化首先你需要在xml中来，配置bean。 默认使用的bean就是用的无参构造其中id就表示这个bean的名字，class就是你要创建这个实例的class– &lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.UserDaoImpl&quot;/&gt; 静态工厂方法实例化这就运用到一个类中的一个静态方法，这个静态方法get就是用来返回bean的实例– &lt;bean id=&quot;userDao&quot; factory-method=&quot;get&quot;class=&quot;com.UserDaoFactory/&gt; 工厂bean的实例化这个方法就用到了工厂模式，这个工厂的方法get用来生产这个bean的实例– &lt;bean id=&quot;userDaoFactory&quot; class=&quot;com.factory.user.UserDaoFactory&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;userDaoFactory&quot; factory-method=&quot;get&quot;/&gt; Spring的factorybean接口使用这种方式就是要类已经实现了FactoryBean的接口，然后重写了方法– &lt;bean id=&quot;car&quot; class=&quot;com.demo.dao.CarFactory&quot;/&gt; 依赖注入依赖注入Spring也给我提供了两种方式 setter注入– 这个方式就是说，你要实例化的对象，必须要有setter方法来设置，然后才能才bean中进行依赖注入 123456&lt;bean id=\"userService\" class=\"com.demo.service.UserServiceImpl/&gt;&lt;bean id=\"userController\" class=\"com.demo.controller.UserController\"&gt; //这里的name其实就是调用的setter方法 &lt;property name=\"userService\" ref=\"userService\"/&gt;&lt;/bean&gt; 1234567891011121314151617181920//当然你想注入其他类型的时候也是可以的//value 注入基本类型 &lt;property name=\"\" value=\"12\"/&gt;&lt;/property&gt;//list 存放基本类型注入list &lt;property name=\"\" /&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;value&gt;&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;//map集合&lt;property name=\"\"/&gt; &lt;map&gt; &lt;entry key=\"\" value=\"\"/&gt; &lt;entry key=\"\" value=\"\"/&gt; &lt;entry key=\"\" value=\"\"/&gt;&lt;/map&gt;&lt;/property&gt; 构造器注入==看完了这些实例化和依赖注入，再来看看怎么使用吧==其中一般来说全局就一个spring容器 bean的作用域范围prototype 原 型 =&gt; 每次创建一个实例singleton 单 例 =&gt;一个bean的定义，只有一个实例，不是之前那种单例 一个类只有一个request 一个请求一个实例session 一个会话一个实例websocket 一次websocket链接一个实例 bean的生命周期声明周期两种方式：==只有单例有效果== 自己写开始结束的方法在bean的配置中，添加init-method=“初始化的方法”，destroy-method=“销毁的方法” 实现开始结束的接口 重写方法在类上实现InitializingBean,DisposableBean 方法 IoC的配置1. 通过注解来配置IoC在XML中配置 1&lt;context:component-scan base-package=\"要扫描的注解的包路径“/&gt; ==注解有==@Controller@Service@Repository 这是dao的@Autowired 自动依赖注入 就可以不用setter@Component 不是上面三层的就统一用这个@Value 注入基本数据类型 可以注入配置的值 作用域用：@Scope（“propertype”）生命周期@PostConstruct 初始化的方法上加@PreDestroy 摧毁的方法上加 ==当你加了注解的时候，Spring会自动将类名第一个首字母小写作为bean的id，因为是加在类上，所以class也省略配置了== 2.Java类配置IoC使用java类来代替XML @Configuration 用于标记一个类为配置类@Bean 标记某个方法返回值为spring的bean@ComponentScan（要扫描的包） 打开扫描包的注解 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class AppConfig &#123; @Bean public UserService userService()&#123;// 第一种推荐 @Bean就是来获得对象的 要注入信息就调用方法 UserService userService = new UserService(); userService.setUserDao(userDao()); return userService; &#125; @Bean public UserDao userDao()&#123; return new UserDao(); &#125; @Bean public UserController userController(UserService userService)&#123;// 第二种 通过传入参数 spring自己找对应的bean UserController userController=new UserController(); userController.setUserService(userService); return userController; &#125; // 获得DruidDataSource @Bean public DruidDataSource druidDataSource()&#123; DruidDataSource dds = new DruidDataSource();// 设置每个属性 dds.setDriverClassName(\"com.mysql.jdbc.Driver\"); dds.setUsername(\"root\"); dds.setPassword(\"root123\"); dds.setUrl(\"jdbc:mysql://localhost:3306/demo); return dds; &#125; @Bean public QueryRunner queryRunner()&#123;// 指定druidDataSource当然也可以不指定 让spring自己去找 QueryRunner qr = new QueryRunner(druidDataSource()); return qr; &#125; &#125; 12345678910111213@PropertySource(\"DataBase.properties\")@Value(\"$&#123;driverClassName&#125;\")String driverClassName;@Value(\"$&#123;url&#125;\")String url;@Value(\"$&#123;username&#125;\")String username;@Value(\"$&#123;password&#125;\")String password; 在使用的时候就得使用下面的进行调用了 1AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigScan.class); @ComponentScan（要扫描的包） 打开扫描包的注解等价于&lt;context:component-scan base-package=”xxx”&gt; 这个时候就要用 @Controller @Service 直接生成bean 就不用自己@Bean来生成bean 多种的混用在注解类上可以使用@Import（.class）导入Java配置 用@ImportResource(.xml)导入Xml的配置 ==讲了这么久 讲讲IoC的优势== IoC优势 解耦合 （一个类跟一个类的关系就是耦合度） 降低了类与类之间的耦合度 提升了代码的灵活性，可维护性。因为一个类可能有多个实现，当不同需求的时候在xml中切换下就行 AOPOOP：这是刚开始学Java就学的面相对象编程今天讨论的是AOP：Aspect Oritented Programming AOP：面相切面编程——为了解决公共、系统的问题 那么哪些是属于公共、系统的问题呢？ 比如打印日志，打印参数调用，执行时间，事务管理，安全验证……. 了解了这些，我们来看下AOP中的名词 名词解释连接点： JoinPoint 需要加入功能的位置(通常是方法) 切入点： Pointcut 真正执行加入功能的连接点，从连接点中选出需要加入功能的连接点 通知： Advice 需要实现的功能 切面： Aspect Java语言中将切入点和通知组装在一起的代码单元 目标对象： Target 要操作的对象，方法（连接点）所在的对象 织入： Weave 将功能加入到切入点中的过程 步骤配置方式1（较为麻烦） 编写service类 编写通知 ， 实现MethodBeforeAdvice接口（等下详细讲通知） 配置xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置目标对象--&gt; &lt;bean id=\"userService\" class=\"com.spring.aop.service.impl.UserServiceImpl\"/&gt; &lt;!--配置通知: 实现了打日志的功能--&gt; &lt;bean id=\"beforeExecution\" class=\"com.spring.aop.component.BeforeExecution\"/&gt; &lt;!--切入点：写到需要增加功能的方法--&gt; &lt;bean id=\"pointCut\" class=\"org.springframework.aop.support.JdkRegexpMethodPointcut\"&gt; &lt;property name=\"pattern\" value=\"com.spring.aop.service.impl.UserServiceImpl.addUser\"/&gt; &lt;/bean&gt; &lt;!--切面：连接切入点和通知，让打日志功能在切入点的位置执行--&gt; &lt;bean id=\"aspect\" class=\"org.springframework.aop.support.DefaultPointcutAdvisor\"&gt; &lt;property name=\"pointcut\" ref=\"pointCut\"/&gt; &lt;property name=\"advice\" ref=\"beforeExecution\"/&gt; &lt;/bean&gt; &lt;!--包装userService--&gt; &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;/beans&gt; 配置方式2 aop：config非环绕式的通知 123456789101112131415161718 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置通知--&gt; &lt;bean id=\"tx\" class=\"com.demo.Trans\"/&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"tx\"&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=\"servicePointcut\" expression=\"executon(* com.demo.aop.*.*(..)\"/&gt; &lt;!--前置--&gt; &lt;aop:before method=\"begin\" pointcut-ref=\"servicePointcut\"/&gt; &lt;!--后--&gt; &lt;aop:after-returning method=\"begin\" pointcut-ref=\"servicePointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; expression语法：转载 https://zhuanlan.zhihu.com/p/63001123环绕式通知，就只需要一个就够了 注解式配置注解式的配置切面就如下的配置：@Aspect 切面@Pointcut 切入点@Around 环绕式@Before 前置@After 后置@AfterThrowing 抛出异常@EnableAspectJAutoProxy 自动扫包等价于aop:aspectj-autoproxy 什么是框架?在特定的领域将总结的最佳实践编写成固定流程，帮助我们更加高效，更为健壮的编写。 总结的最佳实践 ，这就表明框架已经是完成了一些特定的功能，自己已经实现了一些功能，不同的框架完成了不同的功能； 固定流程，说明框架本身是有一套流程，需要实现的功能按照其流程来，就能达到效果。 帮助我们，框架本身是不会运行点，在框架的帮助下，配合其他的程序，框架就能有效的帮助我们省去很多步骤，直接调用其本身，来达到功能的实现。 Spring概诉Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。 Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.0 许可下发布。 Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。 Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。 Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack（一站式）轻量级开源框架。 上面的干货是不是很枯燥，那我们看下Spring ==集成的模块== Spring集成的模块1 核心容器 Spring-beans:IoC的实现，配置文件的访问、创建和管理； Spring-core：核心工具包； Spring-context：封装IoC容器，提供扩展功能； SpEL:Spring的表达式支持 2.基础服务 AOP：面向切面编程的支持； Aspect：模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架； Instrumentation：字节码操作； Messaging：对消息服务的支持 3.功能 transactions:对事务的支持； JDBC:Spring对JDBC的封装； ORM：Spring对ORM的封装 4.WEB Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。 Spring的核心理念——IoC容器在讲解IoC的时候我们先来回想，之前写MVC三层的时候IoC:Inversion of Control 控制反转，通俗一点就是控制权由调用的类，转为Spring容器，由Spring容器来==创建实例以及依赖注入==。 Bean的四种实例化首先你需要在xml中来，配置bean。 默认使用的bean就是用的无参构造其中id就表示这个bean的名字，class就是你要创建这个实例的class– &lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.UserDaoImpl&quot;/&gt; 静态工厂方法实例化这就运用到一个类中的一个静态方法，这个静态方法get就是用来返回bean的实例– &lt;bean id=&quot;userDao&quot; factory-method=&quot;get&quot;class=&quot;com.UserDaoFactory/&gt; 工厂bean的实例化这个方法就用到了工厂模式，这个工厂的方法get用来生产这个bean的实例– &lt;bean id=&quot;userDaoFactory&quot; class=&quot;com.factory.user.UserDaoFactory&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;userDaoFactory&quot; factory-method=&quot;get&quot;/&gt; Spring的factorybean接口使用这种方式就是要类已经实现了FactoryBean的接口，然后重写了方法– &lt;bean id=&quot;car&quot; class=&quot;com.demo.dao.CarFactory&quot;/&gt; 依赖注入依赖注入Spring也给我提供了两种方式 setter注入– 这个方式就是说，你要实例化的对象，必须要有setter方法来设置，然后才能才bean中进行依赖注入 123456&lt;bean id=\"userService\" class=\"com.demo.service.UserServiceImpl/&gt;&lt;bean id=\"userController\" class=\"com.demo.controller.UserController\"&gt; //这里的name其实就是调用的setter方法 &lt;property name=\"userService\" ref=\"userService\"/&gt;&lt;/bean&gt; 1234567891011121314151617181920//当然你想注入其他类型的时候也是可以的//value 注入基本类型 &lt;property name=\"\" value=\"12\"/&gt;&lt;/property&gt;//list 存放基本类型注入list &lt;property name=\"\" /&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;value&gt;&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;//map集合&lt;property name=\"\"/&gt; &lt;map&gt; &lt;entry key=\"\" value=\"\"/&gt; &lt;entry key=\"\" value=\"\"/&gt; &lt;entry key=\"\" value=\"\"/&gt;&lt;/map&gt;&lt;/property&gt; 构造器注入==看完了这些实例化和依赖注入，再来看看怎么使用吧==其中一般来说全局就一个spring容器 bean的作用域范围prototype 原 型 =&gt; 每次创建一个实例singleton 单 例 =&gt;一个bean的定义，只有一个实例，不是之前那种单例 一个类只有一个request 一个请求一个实例session 一个会话一个实例websocket 一次websocket链接一个实例 bean的生命周期声明周期两种方式：==只有单例有效果== 自己写开始结束的方法在bean的配置中，添加init-method=“初始化的方法”，destroy-method=“销毁的方法” 实现开始结束的接口 重写方法在类上实现InitializingBean,DisposableBean 方法 IoC的配置1. 通过注解来配置IoC在XML中配置 1&lt;context:component-scan base-package=\"要扫描的注解的包路径“/&gt; ==注解有==@Controller@Service@Repository 这是dao的@Autowired 自动依赖注入 就可以不用setter@Component 不是上面三层的就统一用这个@Value 注入基本数据类型 可以注入配置的值 作用域用：@Scope（“propertype”）生命周期@PostConstruct 初始化的方法上加@PreDestroy 摧毁的方法上加 ==当你加了注解的时候，Spring会自动将类名第一个首字母小写作为bean的id，因为是加在类上，所以class也省略配置了== 2.Java类配置IoC使用java类来代替XML @Configuration 用于标记一个类为配置类@Bean 标记某个方法返回值为spring的bean@ComponentScan（要扫描的包） 打开扫描包的注解 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class AppConfig &#123; @Bean public UserService userService()&#123;// 第一种推荐 @Bean就是来获得对象的 要注入信息就调用方法 UserService userService = new UserService(); userService.setUserDao(userDao()); return userService; &#125; @Bean public UserDao userDao()&#123; return new UserDao(); &#125; @Bean public UserController userController(UserService userService)&#123;// 第二种 通过传入参数 spring自己找对应的bean UserController userController=new UserController(); userController.setUserService(userService); return userController; &#125; // 获得DruidDataSource @Bean public DruidDataSource druidDataSource()&#123; DruidDataSource dds = new DruidDataSource();// 设置每个属性 dds.setDriverClassName(\"com.mysql.jdbc.Driver\"); dds.setUsername(\"root\"); dds.setPassword(\"root123\"); dds.setUrl(\"jdbc:mysql://localhost:3306/demo); return dds; &#125; @Bean public QueryRunner queryRunner()&#123;// 指定druidDataSource当然也可以不指定 让spring自己去找 QueryRunner qr = new QueryRunner(druidDataSource()); return qr; &#125; &#125; 12345678910111213@PropertySource(\"DataBase.properties\")@Value(\"$&#123;driverClassName&#125;\")String driverClassName;@Value(\"$&#123;url&#125;\")String url;@Value(\"$&#123;username&#125;\")String username;@Value(\"$&#123;password&#125;\")String password; 在使用的时候就得使用下面的进行调用了 1AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfigScan.class); @ComponentScan（要扫描的包） 打开扫描包的注解等价于&lt;context:component-scan base-package=”xxx”&gt; 这个时候就要用 @Controller @Service 直接生成bean 就不用自己@Bean来生成bean 多种的混用在注解类上可以使用@Import（.class）导入Java配置 用@ImportResource(.xml)导入Xml的配置 ==讲了这么久 讲讲IoC的优势== IoC优势 解耦合 （一个类跟一个类的关系就是耦合度） 降低了类与类之间的耦合度 提升了代码的灵活性，可维护性。因为一个类可能有多个实现，当不同需求的时候在xml中切换下就行 AOPOOP：这是刚开始学Java就学的面相对象编程今天讨论的是AOP：Aspect Oritented Programming AOP：面相切面编程——为了解决公共、系统的问题 那么哪些是属于公共、系统的问题呢？ 比如打印日志，打印参数调用，执行时间，事务管理，安全验证……. 了解了这些，我们来看下AOP中的名词 名词解释连接点： JoinPoint 需要加入功能的位置(通常是方法) 切入点： Pointcut 真正执行加入功能的连接点，从连接点中选出需要加入功能的连接点 通知： Advice 需要实现的功能 切面： Aspect Java语言中将切入点和通知组装在一起的代码单元 目标对象： Target 要操作的对象，方法（连接点）所在的对象 织入： Weave 将功能加入到切入点中的过程 步骤配置方式1（较为麻烦） 编写service类 编写通知 ， 实现MethodBeforeAdvice接口（等下详细讲通知） 配置xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置目标对象--&gt; &lt;bean id=\"userService\" class=\"com.spring.aop.service.impl.UserServiceImpl\"/&gt; &lt;!--配置通知: 实现了打日志的功能--&gt; &lt;bean id=\"beforeExecution\" class=\"com.spring.aop.component.BeforeExecution\"/&gt; &lt;!--切入点：写到需要增加功能的方法--&gt; &lt;bean id=\"pointCut\" class=\"org.springframework.aop.support.JdkRegexpMethodPointcut\"&gt; &lt;property name=\"pattern\" value=\"com.spring.aop.service.impl.UserServiceImpl.addUser\"/&gt; &lt;/bean&gt; &lt;!--切面：连接切入点和通知，让打日志功能在切入点的位置执行--&gt; &lt;bean id=\"aspect\" class=\"org.springframework.aop.support.DefaultPointcutAdvisor\"&gt; &lt;property name=\"pointcut\" ref=\"pointCut\"/&gt; &lt;property name=\"advice\" ref=\"beforeExecution\"/&gt; &lt;/bean&gt; &lt;!--包装userService--&gt; &lt;bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/&gt;&lt;/beans&gt; 配置方式2 aop：config非环绕式的通知 123456789101112131415161718 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置通知--&gt; &lt;bean id=\"tx\" class=\"com.demo.Trans\"/&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"tx\"&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=\"servicePointcut\" expression=\"executon(* com.demo.aop.*.*(..)\"/&gt; &lt;!--前置--&gt; &lt;aop:before method=\"begin\" pointcut-ref=\"servicePointcut\"/&gt; &lt;!--后--&gt; &lt;aop:after-returning method=\"begin\" pointcut-ref=\"servicePointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; expression语法：转载 https://zhuanlan.zhihu.com/p/63001123环绕式通知，就只需要一个就够了 注解式配置注解式的配置切面就如下的配置：@Aspect 切面@Pointcut 切入点@Around 环绕式@Before 前置@After 后置@AfterThrowing 抛出异常@EnableAspectJAutoProxy 自动扫包等价于aop:aspectj-autoproxy","categories":[{"name":"spring","slug":"spring","permalink":"https://floatinghua.github.io/categories/spring/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://floatinghua.github.io/tags/%E6%A1%86%E6%9E%B6/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"https://floatinghua.github.io/categories/java/"},{"name":"linux","slug":"linux","permalink":"https://floatinghua.github.io/categories/linux/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://floatinghua.github.io/categories/elasticsearch/"},{"name":"spring","slug":"spring","permalink":"https://floatinghua.github.io/categories/spring/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://floatinghua.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"设计模式","slug":"设计模式","permalink":"https://floatinghua.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"poi","slug":"poi","permalink":"https://floatinghua.github.io/tags/poi/"},{"name":"api","slug":"api","permalink":"https://floatinghua.github.io/tags/api/"},{"name":"springboot","slug":"springboot","permalink":"https://floatinghua.github.io/tags/springboot/"},{"name":"集成","slug":"集成","permalink":"https://floatinghua.github.io/tags/%E9%9B%86%E6%88%90/"},{"name":"海康","slug":"海康","permalink":"https://floatinghua.github.io/tags/%E6%B5%B7%E5%BA%B7/"},{"name":"整合","slug":"整合","permalink":"https://floatinghua.github.io/tags/%E6%95%B4%E5%90%88/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://floatinghua.github.io/tags/elasticsearch/"},{"name":"框架","slug":"框架","permalink":"https://floatinghua.github.io/tags/%E6%A1%86%E6%9E%B6/"}]}